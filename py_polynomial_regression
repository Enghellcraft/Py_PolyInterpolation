# TP Métodos Numéricos - 2023
# Alumnos: 
#          • Bianchi, Guillermo
#          • Martin, Denise
#          • Nava, Alejandro

import numpy as np
from scipy.interpolate import lagrange
import matplotlib.pyplot as plt
import random

coefs = []

# Funs
def calcular_polinomio_interpolador(pares):
    """
    Calcula el polinomio interpolador de Newton a partir de una lista de pares de números enteros.

    Args:
        pares: Lista de pares de números enteros en el formato [(x0, y0), (x1, y1), ..., (xn, yn)].

    Returns:
        coeffs: Lista de coeficientes del polinomio interpolador.
    """
    n = len(pares)
    xs = np.array([p[0] for p in pares])
    ys = np.array([p[1] for p in pares])

    # Crear la tabla de diferencias divididas con el tamaño del dataset
    tabla_diferencias = np.zeros((n, n))
    # Completa la tabla con los valores de y
    tabla_diferencias[:, 0] = ys

    for j in range(1, n):
        for i in range(n - j):
            tabla_diferencias[i][j] = (tabla_diferencias[i + 1][j - 1] - tabla_diferencias[i][j - 1]) / (xs[i + j] - xs[i])

    # Construir el polinomio interpolador
    coeffs = tabla_diferencias[0, :]

    return coeffs


def my_newton_poly(coef, x_data, x):
# where coef is a matrix of coefficients from my_divided_diff
# x_data is the array of x values of the dataset
# x is the array of new X values to witch the Newton poly will evaluate

    n = len(x_data) - 1 
    
    # initialized in the last coefficient of the matrix
    p = coef[n]
    #poly_str = str(p)
    
    # iterates reversely through the matrix
    for k in range(1,n+1):
        # for each coefficient, updates p
        p = coef[n-k] + (x -x_data[n-k])*p
        
        # returns polynomial
       # poly_str = f"{coef[n-k]:+}" + poly_str + f"({x-x_data[n-k]})"
    return p #poly_str

def my_divided_diff(x, y):
    # takes X and Y from the dataset given
    n = len(y)
    
    # creates a matrix, the size of one variable data (datapoints),containing zeros
    coef = np.zeros([n, n])
    
    # sets Y values of dataset to the first column
    coef[:,0] = y
    
    # iterates through the second column 
    for j in range(1,n):
        for i in range(n-j):
            # calculates the jth divided difference coefficient
            coef[i][j] = \
           (coef[i+1][j-1] - coef[i][j-1]) / (x[i+j]-x[i])
           
    # returns matrix of coefficients        
    return coef


def my_lagrange(x_values, y_values, x_new):
    #Where x_values are the values from dataset X
    # y_values are the values from dataset Y
    # x_new are the new values
    
    if len(x_values) != len(y_values):
        raise ValueError("x_values e y_values deben tener la misma")
    result = 0
    for i, x_i in enumerate(x_values):
        l_i = np.prod([(x_new - x_values[j])/(x_i - x_values[j]) for j in range(len(x_values)) if j != i])
        coefs.append(l_i)
        result += l_i * y_values[i]
    return result

# Funcion generadora de 20 pares de numeros enteros aleatorios
# ordenados de manera ascendente 
def generador_pares(cota_minima, cota_maxima):
    pares = np.random.randint(cota_minima, cota_maxima, size=(20, 2))
    return sorted(pares, key=lambda x: x[0])

def separador_pares_x_y(pares):
    print()
    pares_x = []
    pares_y = []
    for i in range(len(pares)):
        pares_x.append(pares[i][0])
        pares_y.append(pares[i][1])
    return pares_x, pares_y    

def inversor_pares(pares):
    reversed = pares[::-1]
    return reversed
  
def aleator_pares(pares):   
    randomness = pares
    return random.shuffle(randomness)

       

# Newton divided difference formula 
  
# Function to find the product term 
def proterm(i, value, x): 
    pro = 1; 
    for j in range(i): 
        pro = pro * (value - x[j]); 
    return pro; 
  
# Function for calculating 
# divided difference table 
def dividedDiffTable(x, y, n):
  
    for i in range(1, n): 
        for j in range(n - i): 
            y[j][i] = ((y[j][i - 1] - y[j + 1][i - 1]) /
                                     (x[j] - x[i + j]));
    return y;
  
# Function for applying Newton's 
# divided difference formula 
def applyFormula(value, x, y, n): 
  
    sum = y[0][0]; 
  
    for i in range(1, n):
        sum = sum + (proterm(i, value, x) * y[0][i]); 
      
    return sum; 
  
# Function for displaying divided 
# difference table 
def printDiffTable(y, n): 
  
    for i in range(n): 
        for j in range(n - i): 
            print(round(y[i][j], 4), "\t", 
                               end = " "); 
  
        print(""); 

# Plots
def graph_details():
    plt.xlabel('x')
    plt.ylabel('y')
    plt.grid(True)
    plt.legend()
    plt.show()

def linear_lagrange(a,x):
    y = a[1]*(x - a[2])/(a[0] - a[2]) + a[3]*(x - a[0])/(a[2] - a[0])
    plt.plot(x,y,color='blue',label='Linear Lagrange')
    graph_details()
    return y

def quadratic_lagrange(a,x):
    t = a[1]*(x-a[2])*(x-a[4])
    s = (a[0]-a[2])*(a[0]-a[4])
    j = t/s
    m = a[5]*(x-a[0])*(x-a[2])
    n = (a[4]-a[0])*(a[4]-a[2])
    i = m/n
    k = a[3]*(x-a[4])*(x-a[0])
    y = (a[2]-a[4])*(a[2]-a[0])
    l = k/y
    y = j + l + i
    plt.plot(x,y,color='blue',label='Quadratic Lagrange')
    graph_details()
    return y

def cubic_lagrange(a,x):
    t = a[1]*(x-a[2])*(x-a[4])*(x-a[6])
    s = (a[0]-a[2])*(a[0]-a[4])*(a[0]-a[6])
    j = t/s
    k = a[3]*(x-a[4])*(x-a[0])*(x-a[6])
    y = (a[2]-a[4])*(a[2]-a[0])*(a[2]-a[6])
    l = k/y
    m = a[5]*(x-a[0])*(x-a[2])*(x-a[6])
    n = (a[4]-a[0])*(a[4]-a[2])*(a[4]-a[6])
    i = m/n
    v = a[7]*(x-a[0])*(x-a[2])*(x-a[4])
    w = (a[6]-a[0])*(a[6]-a[2])*(a[6]-a[4])
    u = v/w
    y = j + l + i + u
    plt.plot(x,y,color='blue',label='Cubic Lagrange')
    graph_details()
    return y 



def zero_newton(a,x):
    return a[1]

def one_newton(a,x,f):
    y = zero_newton(a,x) + ((x-a[0])*(a[1]-a[3])/(a[0]-a[2]))
    if(f==1):
        plt.plot(x,y,color = 'blue',label='First Order Newton Divided Difference')
        plt.legend()
        plt.grid(True)
        plt.show()
    return y

def func_one(x1,x2,y1,y2):
    return (y2 - y1) / (x2 - x1)

def two_newton(a,x,f):
    j = a[4] - a[0]
    i = func_one(a[2],a[4],a[3],a[5])
    k = func_one(a[0],a[2],a[1],a[3])
    j = (i - k) / j
    y = one_newton(a,x,0) + ((x-a[0])*(x-a[2])*j)
    if(f==1):
        plt.plot(x,y,color = 'blue',label='Second Order Newton Divided Difference')
        plt.legend()
        plt.grid(True)
        plt.show()
    return y 

def func_two(x1,x2,x3,y1,y2,y3):
    a = func_one(x1,x2,y1,y2)
    b = func_one(x2,x3,y2,y3)
    return (b - a) / (x3 - x1)

def three_newton(a,x):
    j = a[6] - a[0]
    k = func_two(a[2],a[4],a[6],a[3],a[5],a[7]) - func_two(a[0],a[2],a[4],a[1],a[3],a[5])
    y = two_newton(a,x,0) + ((x-a[0])*(x-a[2])*(x-a[4])*k/j)
    plt.plot(x,y,color = 'blue',label='Third Order Newton Divided Difference')
    plt.legend()
    plt.grid(True)
    plt.show()
    return y
     

def graph():
    plt.ylabel('Error')
    plt.xlabel('x')
    plt.grid(True)
    plt.show()
     


# Prints
## null) Task + Pres
print("                                                                                  ")
print("**********************************************************************************")
print("*            METODOS NUMERICOS - 2023 - TP METODOs DE INTERPOLACION              *")
print("**********************************************************************************")
print("    ALUMNOS:                                                                      ")
print("            • Bianchi, Guillermo                                                  ")
print("            • Martin, Denise                                                      ")
print("            • Nava, Alejandro                                                     ")
print("                                                                                  ")
print("**********************************************************************************")
print("*                                   OBJETIVO                                     *")
print("**********************************************************************************")
print("  Lograr un polinomio interpolador                                                ")
print("                                                                                  ")
print("**********************************************************************************")
print("*                                   CONSIGNAS                                    *")
print("**********************************************************************************")
print("  Se trabaja con 20 pares de números elegidos al azar, (x, y)                     ")
print("                                                                                  ")
print("  1) Primero establecer cotas para los mismos, generar 20 pares de números con    ")
print("  esas cotas. Ordenar los pares según x.                                          ")
print("  2) Generar un polinomio interpolador por esos 20 pares, según el método de Newton.")
print("   Testear el grado del polinomio obtenido y graficar marcando los pares de datos.")
print("  3) Ordenarlos al revés y obtener otro polinomio interpolador. ¿Qué grado tiene?  ")
print("  ¿Es el mismo? ¿Cómo se hace para saber si el el mismo polinomio? Graficar       ")
print("  4) Lo mismo desordenando los pares.")
print("  5) ¿Se puede poner el programa de obtención de raíces como subrutina de este y  ")
print("  buscar al menos una raíz de uno de los polinomios?   ")
print("  6) Pueden hacer una subrutina que halle por Lagrange, con el mismo conjunto de pares? ")
print("  7) Pueden hacer una subrutina que halle por diferencias divididas, con el       ")
print("  mismo conjunto de pares?                                                        ")
print("  ¿Qué se puede decir? ¿Qué conclusiones se pueden sacar?                         ")

## I) Theory
print("                                                                                  ")
print("**********************************************************************************")
print("*                                      TEORIA                                    *")
print("**********************************************************************************")
print(" Los Métodos de Interpolación son técnicas utilizadas en cálculo para aproximar una")
print(" función desconocida a partir de un conjunto finito de puntos conocidos, hallando ")
print(" un polinomio de grado mínimo que pase por esos puntos                            ")
print("                                                                                  ")
print("                             ********* NEWTON *********                           ")
print(" El método de Newton utiliza un polinomio interpolante que se construye como una  ")
print(" suma de términos de los polinomios conocidos a los que se agrega el producto entre ")
print(" una constante y las raices de los puntos hasta allí utilizados en el polinomio.  ")
print(" Logicamente el primer polinomio es de grado cero, es decir una constante y       ")
print(" Teniendo un polinomio Pm(x) con varios puntos tomados en cuenta, podriamos agregar")
print(" el siguiente punto como: Pm+1(x) = P(x) + c * (x - x0) (x - x1) ... (x - xm)     ")
print(" Donde cada valor de x0, x1 ... xm, representan los valores que anulan al segundo ")
print(" término, para usar el polinomio anterior que se ajustaba a dichos puntos del set")
print(" C es una conmstante que despejada en cada nuevo polinomio, tiene formato:        ")
print("                 ym+1 - Pm(xm+1)                                                  ")
print(" C = ________________________________________                                     ")
print("     (xm+1 - x0) * (xm+1 - x0) *  (xm+1 - x0)                                     ")
print(" Donde ym+1 es el valor correspondiente al par de xm+1, y Pm(xm+1) es el polinomio")
print(" anterior evaluado en el x del set actual: xm+1                                   ")
print(" La cantidad de datos (n) condiciona el grado del polinomio (P):  gr(P) <= n      ")
print("                                                                                  ")
print("                           ********* LAGRANGE *********                          ")
print(" El método de Lagrange utiliza un polinomio interpolante que se construye como una")
print(" suma de polinomios para cada uno de los puntos del set:                          ")
print(" P(x) = L0(x) y0 + L1(x) y1 + … + Ln(x) yn                                        ")
print(" Donde cada polinomio de lagrange ( L ) evaluado en cada punto del set, puede ser ")
print(" expresado genéricamente como:                                                    ")
print("            (x - x0) * (x - x1) ..... ( x - xn )                                  ")
print(" Li(x) = _________________________________________                                ")
print("            (xi - x0) * (xi - x1) .... (xi - xn)                                  ")
print(" En el demonimador ueda logicamente una constante que depende del valor evaluado  ")
print(" y en el numerador las variables que permiten hacer el polinomio.                 ")
print(" La cantidad de datos (n) condiciona el grado del polinomio (P):  gr(P) <= n      ")
print("                                                                                  ")
print("                     ********* DIFERENCIAS DIVIDIDAS *********                    ")
print(" El método de Diferencias Divididas utiliza un polinomio interpolante que se      ")
print(" construye como una sumatoria de diferencias dvididas, según sea:                 ")
print(" • Progresivo:                                                                    ")
print(" Pn−1(x) = f [x0] + f [x0, x1] * (x − x0) + f [x0, x1, x2] * (x − x0) * (x − x1) ···")
print(" .... + f [x0, x1, ... , xn] · (x − x0) · (x − x1) ... (x − xn−1)                 ")
print(" • Regresivo:                                                                    ")
print(" Pn−1(x) = f [xn] + f [xn, xn−1] * (x − xn) + f [xn, xn−1, xn−2] * (x − xn) * (x − xn−1)")
print(" .... + f [xn, xn−1, ... , x1] * (x − xn) · (x − xn−1) ... (x − x1)                ")
print(" Donde se toma todo el dataset y se realiza las diferencias divididas de todos.   ")
print(" En ambos casos el resultado debería ser igual o similar.                         ")
print("                                                                                  ")

## II) Examples
print("                                                                                  ")
print("**********************************************************************************")
print("*                                    EJEMPLOS                                    *")
print("**********************************************************************************")

print("                                                                                  ") 

# Llamamos a la funcion para generar los 20 pares aleatorios e imprimimos en pantalla
pares = generador_pares(0, 10)
print("Los 20 pares generados aleatoriamente son: ")
for i in range(len(pares)):
    print(pares[i])
    
pares_x, pares_y = separador_pares_x_y(pares)
print(" Los elementos x son: \n", pares_x)
print("Los elementos y son: \n", pares_y)

inversed = inversor_pares(pares)
print("Los elementos invertidos son: \n")
for i in range(len(inversed)):
    print(inversed[i])

randomness = pares
random.shuffle(randomness)
print("Los elementos aleatorizados son: \n")
for i in range(len(randomness)):
    print(randomness[i])

## IV) Conclusions
print("                                                                                  ")
print("**********************************************************************************")
print("*                                  CONCLUSIONES                                  *")
print("**********************************************************************************")
print(" • El método de Lagrange utiliza una fórmula de interpolación que se basa en las  ")
print("   ordenadas de una función en cambio Newton y Diferencias Divididas requieren las")
print("   ordenadas y absisas para su desarrollo.                                        ")
print("                                                                                  ")
print(" • El método de Lagrange solo se utiliza para la interpolación, mientras que el de")
print("   Newton y Diferencias Divididas se pueden utilizar para interpolación y extrapolación.") 
print("                                                                                  ")
print(" • La ventaja del método de Lagrange es que es fácil de entender y aplicar.       ")
print("   Sin embargo, no es eficiente para grandes conjuntos de datos (limitación).     ")                                     
print("                                                                                  ")
print(" • La ventaja del método de Diferencias Divididas es que es sencillo y no hay que ")
print("   recalcular coeficientes. Sin embargo, tiene que tener suficiente presición para") 
print("   entenderse y no permite cambios muy grandes (por su similitud con derivadas).  ")                                      
print("                                                                                  ")
print(" • Los tres métodos permiten encontrar una función polinómica que pase por un     ")
print("   conjunto de puntos de manera continua, generalizando la propiedad euclidiana de") 
print("   que por dos puntos distintos pasa siempre una (única) recta.                   ")                                      
print("                                                                                  ")
print("                                                                                  ") 
